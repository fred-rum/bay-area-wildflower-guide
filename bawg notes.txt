Make new chris-nelson GitHub account and move the BAWG there.
Rename indexedDB to bawg_db (no version #)
Rename cache to bawg_cache (no version #)

>Make separate pages (and links) for flower lists (by color and "all")
with names only (for bandwidth saving) and photos only (for showing off).

Print errors:
  *no color listed
  *listed color not supported
  *broken photo
  no scientific name for leaf page
  multiple scientific names from observations.csv

###############################################################################

favicons generated by:
https://realfavicongenerator.net/

how to mass rename files:
for f in *.jpg; do git mv "$f" "$(echo $f | sed 's/-\([-0-9]*\)\.jpg$/,\1.jpg/')"; done

###############################################################################

clip-art icon source:
https://icon-library.com/png/148553.html

###############################################################################

Create a script to help copy new and changed files to a portable device.
  Copy new and modified files to a new (and git-ignored) folder,
    ready for the user to copy them over using Windows Explorer.
  Record the timestamp of all files to a (git-ignored) database
    to be used next time for identifying new and modified files.
  Deleted files won't be deleted, but they won't cause any harm.
  Include top-level files that should be copied if they are modified,
    e.g. index.html, bafg.css, search.js, pages.js
  Perhaps allow an argument with a date so that all files modified
    after that date are copied in case the database gets screwed up.
  (Explorer displays the photo creation date, but the file modification
    data is still correct internally.)

Should autogenerated families be structured more like top-level lists
(with a complete indented hierarchy)?

Put month info in table format with bar chart.
Put month info side by side with park info (depending on display width?)

/cygdrive/c/Python37/python -m cProfile -s cumtime src/bawg.py | less

Add (optional) color info for unobserved flowers?
How would that be presented?  (border on CalPhoto placeholder?)

Make links up to the key (or any other parent) use an anchor position
that highlights the child's section of the key, similar to the
glossary.  (May require similar positioning tricks.)

Have a way to link from txt to the key to a flower (e.g. for
rough-fruited buttercup in buttercups).
E.g. {-buttercups#rough-fruited buttercup}

If all modified pages are under a single modified parent (excluding
"all" and color lists), bring up that parent page automatically.  (Or
simply list it first, or list the modified pages hierarchically.
Might be able to reuse the html generation for color lists.)

Support color:none for non-flowering plants.  Allow it to be used at
an upper level of hierarchy, from where it automatically propagates
downward through the tree.  (Should I also allow propagation for other
colors?  It could come in handy, e.g. for a genus that is always the
same color.  But it would also make it easy to be sloppy and not
verify the correct color of everything.)

For HTML files, use the scientific name instead of the common name if
possible?  This reduces churn when common names change, but it makes
it harder to find the corresponding txt file.  In any case, common
names don't change often, and scientific names can change, too.

For a line that begins with '[', include an automatic h3 or lower
format on the remainder of the text line.  Use increasing header
numbers based on the bracket depth.  Line breaks remain <br/>.
Recognize this and continue the header, or require that the line be
run together with <br/> in the middle?

Parts of a pea flower:
https://en.wikipedia.org/wiki/Papilionaceous_flower#/media/File:Sesbanea_bispinosa,_crop.jpg

The banner is a single petal, but a crease along its midline may give
the appearance of two petals fused at the edge.


sea muilla:
perianth parts (no obvious corolla/calyx separation)
sepals (in bud, but opening) (no calyx tube)
filaments, anthers, pollen
ovary, style, stigma
pedicels
bracts
peduncle

milk maids:
petals
sepals

buttercup:
petals
sepals
pedicels
bracts
peduncle
anthers
pistil hard to see

sun cup:
petals
sepals
pedicel
anthers, filaments
stigma, style hidden
bracts out of view

field bindweed (2 photos)
petals
calyx (sepals indistinct)
pedicel
ovary/style/stigma
filaments/anthers

yellow mariposa lily: (2 photos; bawg photos are good)
petals
sepals
anthers, filaments
stigma, ovary
pedicel
no bracts

pale flax
good side view down to bracts
top view shows all the parts, but is too crowded to label


Add glossary entries to replace as many Jepson terms as I can.  If I
can get all of them, then perhaps I can make use of a Jepson term an
error.


Apply standard page substitutions on glossary pages, e.g. blank lines
to <p/>.

Add inflorescence shape definitions for sedges.  (Possibly share the
glossary with grasses, but probably not.)


Detect when a glossary term is defined twice in the same file (or
definition) (e.g. a typo).

Allow iNaturalist taxon ID to be specified in txt since iNaturalist
fails for shared genus names, e.g. onions (Allium).

Separate surprise_obs into multiple parts:
  species that don't have a page despite there being a genus page
    (or should it be all plant species that don't have a page?)
    (includes subspecies if the species page is missing.)
  subspecies that have a common name and a genus page (or are plants),
    but no page.
  subspecies that don't have a common name but are under a species
    for which subspecies are listed.


It'd be nice to link to a section of glossary words with the selected
one highlighted.  E.g. clicking "pedicel" would link to "Parts of a
flower" (highlighted in pale gray) with the "pedicel" entry
highlighted in yellow partway down the page.  This would require
Javascript for the yellow highlighting using extra information in the
URL, e.g. flower%20glossary.html?term=pedicel#parts+of+a+flower.  A
mobile screen is often too small for the section (especially if it
includes figures, but even without them).  Is some other solution
possible to indicate that the linked term is part of a section?

Now that glossary terms are flagged when used out of place, try moving
many of the plant glossary entries to the flower glossary.  Perhaps a
command-line arg could flag glossary terms that are never used in the
'plant glossary' context.


Use img property alt="" to indicate to blind users that a description
of the photo is not helpful?

I've removed the search penalty for autopropagated and unobserved pages.
I should also order them lower in pages.js.


Make the hierarchy more generic to fit anyone's taxonomic priorities:

'is_top' marks a page as being the top of a hierarchy.  Any
descendants of this page or pages that list this one as a higher-level
group are considered part of its hierarchy, so they won't be assigned
a hierarchy as per below.

'default_ancestor' marks a page as being the top of a hierarchy, *and*
any hierarchies that don't have an 'is_top' root are considered to be
part of its hierarchy.  Only one page can be marked
'default_ancestor'.  Does *not* imply 'is_top'.  E.g. flowering plants
may be the 'default_ancestor' while being under vascular plants, etc.

When checking ancestor properties, a page searches up through all
parents and also through all resolved groups from observations.csv.
In addition, a variety/subspecies is deemed to be a member of its
species, and a species is deemed to be a member of its genus,
regardless of observations.csv entries.

'create: <rank>' allows descendants to be added at the specified rank,
e.g. 'create: family'.  Pages are thus created automatically from
observations.csv.  Implies 'list: <rank>'.  This may be the hardest
property to handle in order to build a hierarchy in the correct order.
Perhaps iterate through each rank from bottom to top.  For each top of
hierarchy, check if it can and should create a page at the current
rank, and then do so.  (can = has a resolved group; should = has an
ancestor among resolved groups with the necessary 'create' property.)
At the same time, add parent/child relationships based on 'create',
'list', and 'hierarchy'.

'list: self' marks a page to allow children to be added via group
identification.  Otherwise, a group with incomplete children flags an
error.  'list: <rank>' allows children to be added to all descendants
that are the specified rank.

'require: <rank>' requires descendants below the specified rank to
have an ancestor at the specified rank, e.g. 'require: family'
requires that all flowers have a family.  Often accompanies but does
not require 'create: <rank>'.  If 'create: <rank>' is not specified,
the appropriate hierarchy must be created by hand.

'complete: <rank>' requires that any descendant page of the specified
rank must have as descendants all pages under that page's group.
I.e. if a page is a member of a 'complete' page, it must be an
explicit descendant.  Additionally, if at least two pages exist for a
group of the specified rank, the page for the group must exist.
E.g. 'complete: genus'

'hierarchy: self' marks a page to have its whole hierarchy listed.
Implies 'list: self' (below)?  'hierarchy: <rank>' is less useful to
me, but could perhaps be supported if easy.

'membership: self' causes all descendants to list themselves as a
member of the page.

'membership: <rank>' causes all descendants below the specified rank
to list themselves as a member of their ancestor at the specified
rank.  E.g. 'membership: family'.

Suppress write_lists for hierarchy above genus, e.g. in flowering plants.


Create a function to easily compare ranks beyond just genus/species.
Flag an error for unknown ranks when the sci name is "[rank] [Name]".

When specifying <rank> as part of a property, <rank> can be a range,
e.g. 'genus-family'.  The range can be in either order,
e.g. 'family-genus'.  Additional ranks/ranges can be specified,
e.g. 'genus, species, subspecies'.  If a page doesn't have a rank
(e.g. because it doesn't have a scientific name), it is considered
part of a range if it has both a parent and a child within the range.

<rank> can also be 'self', which refers to the marked page's rank.  If
the marked page doesn't have an explicit rank (e.g. because it doesn't
have a scientific name), it still marks itself, but only for
properties that can be performed on a complete hierarchy
(e.g. 'membership'), not properties that require group identification.

Rank properties are searched from a page as follows:
  - Recurse upwards through the hierarchy, including all choices of parent.
  - If the property is found, return the specified rank range through the recursion.
  - Any page that is in the rank range and any assigned group that is in the rank range is added to a list that is also returned.
  - The final result is a list of names (of pages that don't exist) and/or pages (that do exist) and/or ranks that weren't found.
  - E.g. [('genus', <Page>), ('tribe', None), ('family', 'Roseaceae')]
  - The list is preferably in rank order.
  - The list can include the page that specifies the property.
  - The list can include the page that initiated the search.

How the list is used:
  - create:
    if the lowest-ranked page on the result list doesn't exist, it is created,
      and the top page of the existing hierarchy is added as a child.
    if the lowest-ranked page on the result list does exist,
      the top page of the existing hierarchy is added as a child
      (if it isn't the same page).
  - list: as the last sentence above for create.
  - require: throw an error if any ranks weren't found
  - complete:
    if any page on the result list doesn't exist, we note its name
      associated with the top page of the existing hierarchy below it.
      if its name was already associated with a different page, throw an error.
    if any page on the result list does exist, verify that it is the top page
      of the existing hierarchy.
    what should we do if no page is known for the indicated rank?
      throw an error seems best.  the text should at least declare the
      rank that is being completed by a lower group, even if there is no such
      page.
  - hierarchy: apply if the page itself is in the list (lowest ranked).
  - membership lists the page as a member of all existing pages in the list.


ryegrass's lists doesn't include 'other flowers' because it has
exactly one child with color 'other'.  That is dumb, and it should be
listed with color 'other' even if doesn't appear on the list page.


Format glossary ToC better so that it is clearly a part of the
"Glossary table of contents", especially when "plant glossary" is the
current glossary and thus bold and not linked.

Instead of using index numbers as temporary child IDs, use the
scientific name (if available) or the common name.  These are
guaranteed to find the correct page later unless there is an error
elsewhere.  (Except that I might not know scientific names until
later.  Hm.)

To speed Javascript or CSS editing, allow a parameter to bawg.py to
reference src/search.js and src/bawg.css directly.  (But what about
index.html?)

Make the placeholder text in the search field a much lighter shade of
gray.


Support searches for "help", "bawg", "bay area wildflower guilde",
"contact me".


A subgenius eludes my script's ability to recognize.  Add 'genus' to
the exported taxon list to help resolve it.

Add support in find_property() for guessing genus and species group
ancestors based on partial names.


Move intelligence about 'higher ranks' into resolve_group()

Remove group_child_set, which is no longer used.

Restore support for checking that all families are identified under
flowering plants.


When a top page creates a new page, it can also create a page for
every higher rank for which pages get created.  (Or perhaps re-do the
search for the new page, in case there are hierarchy complications.)

If page creation/linking is enabled for any lower ranks, then pass the
property results down down into the children for processing.
(Except... what if a lower page in the hierarchy has its own
properties?)  It almost seems like I need to resolve_groups for any
pages that need it, then start from each property and work downward
through the hierarchy and shadow hierarchy.  Perhaps it is equivalent
to keep the current upward search from every page, but allow every
page on the path to create/link a page according the results passed
through it, and then mark every page along the path as complete.  Any
future search that hits that page immediately returns with the results
that remained when that page was done.


Current thinking:

Build a shadow tree so that I can search up or down.  Include real
pages (with or without a rank) and group placeholders.  A page without
a rank is ranked just below the lowest common ancestor of all
children, and that LCA is its parent.  Tree traversal can skip up
through the unranked page or traverse the normal group hierarchy
around it.

Nodes in the shadow tree can be looked up by iNaturalist scientific
name to facilitate creating links from observations.csv.
family_names.yaml allows a common name to be converted to a scientific
name in case a page declares a group by common name.  When a new node
is created, it checks for a corresponding page (by scientific name or
iNat sci name) and cross links it.  When a new page is created for a
group, it is also cross linked.

Properties are copied from the real tree and thereafter are associated
with the shadow tree.  Properties are pushed down through all child
paths to all applicable ranks (e.g. for 'create: family', it is pushed
to the family rank).  Note that for this purpose, the node only needs
to keep track of the property name; the rank is implied, and
alternative ranks for the property are not needed.

For performance, I could record the set of pages for each rank of each
property, but that doesn't seem necessary.

From lowest to highest rank, for each page that has a property, apply
that property.  E.g. for 'create', the page is created if it doesn't
exist, and a link is created from each child.  If the shadow child is
not real, continue descending the tree to find the first real child on
each path.

Because a tree can split and rejoin through an unranked page, the
above procedure could create a link to a page when it has a real
ancestor that already gets a link (or already has a link).  Possible
solution: create a set of links to be created without yet creating
them.  Then traverse up through the real hierarchy of each "child" and
delete that child from the set if it finds any ancestor also in the
link set (or already linked).  Only create links after trimming the
set in this way.


--

'-db test' causes txt, photos, glossary, and prev, html, thumbs to be
prefixed with 'test_'.  (Don't forget to add 'test_*' to
'.gitignore'.)  Populate test_txt with only a small set of files in
order to develop and test tree-building code.  (index.html will still
have links to the original locations, but that's easy enough to work
around, so a change to index.html doesn't seem necessary.)  Files from
the 'data' directory look innocuous, so their usage doesn't need to
change.  Perhaps I'll get some warnings about observed flowers not
having pages that I'll have to disable.

--
Linnaean Tree

The Linnaean tree (shadow hierarchy) is maintained using regular pages
that aren't necessarily output to HTML.  If a page exists purely for
the shadow hierarchy, it is not included in page_array, which keeps it
out of scans of "all pages".  The taxon tree relationship is
maintained in each page using a taxon_parent link and a taxon_child
set that are separate from the normal parent/child links.  A
taxon_parent or taxon_child may duplicate a parent/child link; any
code that casres can easily check whether a pointer exists in both
links.  A shadow page is marked as such upon creation with
shadow=True.  If the shadow page is later converted to a real page,
shadow is set to False, and the page is added to page_array.

Shadow pages can be looked up in sci_page, com_page, or isci_page as
usual.  Possibly shadow pages have reduced priority when there is a
common name conflict.

Whenever set_sci() is called for a page, its rank is determined from
its name.  Hopefully I've consistently used "spp." for genuses, so if
I ever get a weird one like "Esula" (a subgenus), I can set its rank
to None, the same as pages without a scientific name.

Whenever assign_child() is called for a page, we check for various
errors.  A circular loop or a child assigned twice is already checked.
Also check that the parent has a higher rank than the child.  (If the
parent doesn't have a rank, traverse all of its parents to find every
possible ancestor rank.  If the child doesn't have a rank, traverse
all of its children to find every possible descendant rank.  For these
purposes, taxon_parent and taxon_child are also traversed.  For
efficiency, only non-duplicate links are traversed.)  Note that a
circular loop is a special case of the search for an ancestor rank
that returns to the original page.

When a normal link is created with assign_child(), we also attempt to
create a shadow link.  If the parent and child each have a rank, then
the shadow link can be created right away.  If the parent does not
have a rank, then we traverse its ancestors and shadow_parent, and
create a shadow link from the child to the lowest-ranked ancestor
found on any path.  (It's conceivable that by accident or design, an
unranked page has different ranked ancestors.  Hopefully they're at
least in the same taxonomic chain, but at this time I don't plan to
check.)  If the child does not have a rank, then we traverse its child
and shadow_child links and create a shadow link from the parent (or
its lowest-ranked ancestor) to the first ranked descendant found on
each descendant path.  Note that at this time we don't create a shadow
link to or from an unranked page.

Shadow links (taxon_parent/taxon_child) are initially added between
pages by these causes:
- A normal link is created which also creates shadow links
- A genus/species group is implied by a species/subspecies name
- A group is declared in the txt (e.g. 'family: grasses')
- A taxonomic chain is read from observations.csv

A taxonomic chain from observations.csv is likely to be complete, but
the others are not.  (A taxonomic chain could be incomplete depending
on how I address discrepancies in the iNaturalist hierarchy.)  In
particular, some ranks may initially be skipped as the shadow tree is
built (e.g. because a subspecies is a direct child of a genus), but
then we attempt to add the skipped ranks to the tree later (e.g. from
observations.csv).  This situation can be recognized when we attempt
to create a shadow link, but the child already has a parent which is
not the one we're trying to link.  If the old and new parents have the
same rank, flag an error.  If the new parent has a lower rank than the
old parent, insert the new parent between the child and its original
parent.  (The old parent becomes the parent of the new parent.)  If
the old parent has a lower rank than the new parent (e.g. because the
txt specified the tribe group and then the family group), then instead
of adding the link from the child, we try to add the new parent as a
parent of the old parent (continuing to recurse as necessary).

Note that an iNaturalist group name can differ from my group name only
if I have a txt file for that page.  In that case, the page is created
with its canonical name, and data from observations.csv can find the
page via isci_page.  If a shadow page is created from observations.csv
(using an iNaturalist-supplied name), it may eventually get promoted
to a real page, but it can never have its name changed to something
different.  Note that a group declared in the txt is expected to use
my canonical name, not the iNaturalist name (although they can be the
same, of course).

After creating and linking all pages and shadow pages (i.e. after
reading observations.csv), some pages will be left without a parent or
Linnaean parent.  In simple cases such a page either has 'is_top' set,
or it wants to be placed under default_ancestor.  But there are
exceptions:

- A shadow page could have been created as a Linnaean ancestor of an
'is_top' page.  In this case, we don't want to place the shadow page
under the default_ancestor.  Instead, we want to propagate 'is_top' up
to the top of the Linnaean hierarchy.

- An unranked (real) page could find a closer ancestor that we'd
rather put it under than the default ancestor.

- A combination of these would have an unranked 'is_top' page in which
a ranked child has Linnaean parents.  Whether or not the unranked
'is_top' page can find a closer ancestor, it wants to make sure that
its children's Linnaean ancestors are marked 'is_top'.

We can mix the order of propagating 'is_top' up (or down) relative to
resolving unranked pages' ancestors.  I.e. both processes can be mixed
in one pass over all (real) pages.  A second pass can then assign the
default_ancestor where needed.  Ultimately, we want every page without
a Linnaean parent to either have 'is_top' set or be assigned the
default_ancestor.

Pass 1: propagate 'is_top' and resolve unranked pages' ancestors

If a ranked page has 'is_top', it is moved/copied to the top of its
Linnaean hierarchy.  Note that we don't really expect any pages along
the propagation chain to have a real parent, as that would imply that
'is_top' isn't placed optimally.  Perhaps flag a warning for this
case, and/or propagate into the real parents as well.  On the other
hand, multiple pages can propagate 'is_top' to the same shadow
ancestor, and that's fine.

If an unranked page has no Linnaean parent, then it is resolved using
the following process.

If a (real) page has no rank and no Linnaean parent then we try to
"resolve" it to have a Linnaean parent.  This parent is defined to be
the lowest common child ancestor (LCCA), i.e. the lowest-ranked
Linnaean ancestor shared by all real children.  (Note that an unranked
page shouldn't have any shadow children).  For each real child, we
traverse its Linnaean ancestry and return a set of all of its
ancestors.  We take the intersection of all children's sets to get the
set of common child ancestors (CCA).  The lowest-ranked ancestor in
this set is the LCCA.

If the children do not share any ancestors (including the case where
some child has no Linnaean parent at all), then the CCA set is empty,
and no LCCA is assigned as the Linnaean parent.

Example:
'nifty flowers' has children 'Clarkia spp.' and 'Taraxia ovata'.
'Clarkia' has ancestors 'family Onagraceae', 'flowering plants', etc.
'Taraxia ovata' has ancestors 'Taraxia spp.', 'family Onagraceae',
  'flowering plants', etc.
The CCA are 'family Onagraceae', 'flowering plants', etc.
The LCCA is 'family Onagraceae'.

If we need to get the ancestor set of an unranked child with no
Linnaean parent, we recurse and resolve the child, then continue with
the original resolution.  If we need to get the ancestor set of an
unranked child that has a Linnaean parent, then we must have already
resolved it, and we can gets its ancestor set without needing to
resolve it again.

When resolving a ranked child without a shadow parent, we return the
empty set.  Either we're in an 'is_top' situation, in which case we
expect the hierarchy to already be sufficiently complete without
assigning Linnaean ancestors, or we're not, in which case we'll end up
assigning the default_ancestor to both the ranked child and the
unranked page that we're trying to resolve.

In case we end up not finding an LCCA at any level of recursion, we
pass the 'is_top' value down to each child as we recurse into it.  The
child then passes 'is_top' up the chain as it gets its ancestor set.
As a convenient side effect, if we *do* find an LCCA, then we know
that it has already received 'is_top' from all children.

Pass 2:

If a page (real or shadow) has a rank but doesn't have a Linnaean
parent, and 'is_top' isn't True, then we set its Linnaean parent to
the default_ancestor page.


Once the shadow tree is entirely built, the properties can be
processed...

All (real) pages are scanned, and each property is pushed down into
all descendants.  Properties only apply to 'self' and to ranked
pages, but they are also pushed through real descendants (not just
shadow descendants) since some unranked pages won't have shadow
descendants.  For efficiency, a shadow descendant isn't traversed if
it duplicates a real descendant.

A 'self' property is not pushed down at all.  A ranked property is
left on any page with a matching rank.  This is recorded differently
than the original property dictionary (which included a set of ranks
for each property), but is simply the existence (or not) of each
property on each page.  (E.g. call it 'prop_set', as opposed to
'prop_ranks'.)

While pushing down properties, a descendant page may declare its own
ranks for a property that is being pushed down.  By default, the
property takes the union of the descending ranks and the declared
ranks.  However, if the declaration includes 'replace', then only the
declared ranks are applied to that page or below.  'replace' can
appear with no ranks specified, in which case propagation ends for the
property.  E.g. 'create: replace'.  This 'replace' concept might not
be terribly useful since for properties like 'create' or 'no_create'
or 'no_orphan', the most likely place to want to replace the
properties is on the shadow page that applies the property, but shadow
pages can't declare their own properties.  Does it make sense to
instead have another set of property overrides that apply to the
descendant end of a link?  E.g. 'no_no_orphan' on an individual
species would exclude it from a 'no_orphan' check applied to its
genus.  In this case, instead of naming properties things like
'no_orphan', 'flag_orphan' may be better.

For each rank from lowest to highest, all pages and shadow pages are
scanned.  I.e. we need an array of all pages, not just real pages.

If a ranked (real or shadow) page has a 'create', 'link', 'no_create',
or 'no_link' property, then a set of descendants to (potentially) link
to the page is created.  The shadow tree is traversed to find the
first 'real' descendant along each path.  (The real tree isn't
traversed because that's a link that already exists and doesn't need
to be re-created.)  Once a real descendant is found, we check to see
if it has a real parent which is in the same Linnaean tree.  This can
only occur if the real parent is unranked (since a ranked parent would
have been found first in the descent).  So, once a real descendant is
found, we check the Linnaean ancestor chain of each of its real
parents.  If the ancestor chain includes the original shadow page,
then the real parent (or perhaps one of its ancestors) will get a
link, and there's no need to create another one to lower in the tree.

I.e.
- Start the search from ranked page 'X' with the applied property.
- From 'X', find each Linnaean descendant, 'Y'.
- From 'Y', find each real parent, 'Z'.
- If no 'Z' has Linnaean ancestor 'X', then a link can be created
  from 'X' to 'Y'.

The action to take depends on the property, whether the page it
applies to is real or shadow, and the number of links that can be
created from it.

In all cases below where links are created, the child pages are sorted
so that pages with more observations are linked first.

For 'obs' on a shadow page, an error is flagged if the taxon appears
in observations.csv (as long as it is in the bay area and not in
ignore species.yaml).

For 'photo' on a real page, an error is flagged if the taxon is
observed and the page does not have a photo (directly on the page or
propagated up from a descendant).

For 'create' on a shadow page with at least one pending link, the page
is promoted to 'real', and the links are created.  If the shadow page
has no real descendants and thus can't create any links, the page must
have been created from observations.csv for a section of hierarchy
that we don't have pages for.  A later property can check for this
condition if we care.

For 'create2' on a shadow page with at least *two* pending links, the
page is promoted to 'real', and the links are created.  If only one
link is possible (i.e. we'd create a rather boring extra level of
hierarchy), nothing is done.

For 'create' or 'create2' on a real page, nothing happens, no matter
how many links could potentially be created.  A 'link' can create
these links as desired, or a 'no_link' property can complain about the
missing links.

When the 'create' property promotes a page to 'real', if the page also
has the 'common' property, then the common name must be defined in
family_names.yaml (or 'n/a').  For any explicitly created page, I
assume that the

For 'common' on a shadow page, if the page is promoted to a real page
by the 'create' property, then the common name must be defined in
family_names.yaml.  (A common name from observations.csv is
insufficient.)  Regardless of the 'common' property, if the common
name is given, it is applied to the promoted page.

For 'link' on a real page (with at least one pending link), the links
are created.

There is no 'link2' property.  If the page exists, there's no reason
not to link to it.

For 'link' on a shadow page, nothing happens.

For 'no_create' or 'no_create2' on a shadow page, an error is flagged
if the corresponding number of links could be created.

For 'no_link' on a real page, an error is flagged if any links could
be created.

For 'no_orphan' on a shadow page, an error is flagged if all Linnaean
descendants that are real do not share a common ancestor via real
links.  (If there is only a single real Linnaean descendant, it is its
own ancestor, which is fine.)  This is a bit looser than 'no_create2';
it doesn't require that the common ancestor is the page with the
property applied, but instead only requires that there is a common
ancestor somewhere.  Note that this check is run before creating links
for higher ranks, so the descendants won't trivially share a common
ancestor such as 'flowering plants'.  Should the check for Linnaean
descendants stop at the first real page on each path (relying on
'no_link' to find orphans below that page) or continue all the way to
the bottom?

I'll have the 'flowering plants' page assert 'no_orphan: genus' and
'no_link: genus-below'.  Thus, if a genus has at least two members, I
expect a txt page for that genus.  And if a genus or species has a
page, then all members of that genus/species must have an explicit
link from that page.  Note that this allows a genus page to directly
link to multiple varieties of the same species without an intermediate
species page if desired.  If I wanted to require a species page as
well, I could instead assert 'no_create2: genus-below'.

Other properties are handled as follows:

While 'require' is being pushed down to matching ranks in the
hierarchy, an error is flagged if it the tree traversal skips over a
rank specified by the property.  E.g. for 'require: family', an error
is flagged if a genus is found in the tree (e.g. as a descendant of
the default_ancestor), but its family isn't known.  This could
potentially flag an error when there is no real page below the missing
group, but the lower-ranked shadow page could only have been created
by observations.csv, which I expect to be complete.  There is no error
if the descendants peter out without reaching a required rank.

If a page is marked 'hierarchy', then its entire hierarchy is output
after any txt in the page.  The expectation is that the hierarchy
comes from automatically generated links, not explicit children.  To
support this, links created by the 'create' or 'link' properties don't
add the link to the txt (only to the child set) if the page has the
'hierarchy' property.

While emitting the HTML for a page, we search all shadow ancestors for
the 'member_link' property.  If an ancestor exists but isn't an
immediate real parent, the page is listed as a 'member of' the
ancestor (including an HTML link to the page).

Similarly, if an ancestor has the 'member_name' property and is *not*
'real', the page is listed as a 'member of' the ancestor (obviously
not including an HTML link).

When checking the shadow hierarchy, some pages (e.g. needle grasses)
might confuse the checks by including species of multiple genuses
while pretending that they are part of a single genus (e.g. because
Jepson classifies them that way).  Perhaps a page can specify a list
of scientific names that it satisfies the requirements for.  And
perhaps that list of names can be included as the "scientific name" on
the page (although only one would be included in links), and all of
its names can be included in pages.js.



When a 'genus' page includes species of multiple genera, it creates a
conflict in which the 'genus' page thinks it must be a member of
another genus.  The simple solution is to simply remove the scientific
name from the page.  But that sometimes means changing the name of the
txt file, as well.

asci: [name] specifies an alternative scientific name that maps to the
same page.  E.g. if the page for 'Aaa spp.' has 'asci: Bbb spp.', then
a child species of 'Bbb Zed' will look for its taxonomic parent 'Bbb'
and find it on page 'Aaa'.

Instead of asci, a more flexible solution would be to allow groups
declared in the txt to override the species/genus guesses from the
name.  E.g. if Bbb Zed declares that is a member of genus Aaa, then it
won't try to add Bbb as a Linnaean parent.  This could also
potentially override the taxonomy read from observations.csv if so
desired.  Requiring a genus group to be repeatedly declared for every
species member is slightly painful, but it's a useful reminder that
the user is doing something unorthodox.  In any case, this scheme
allows members of a genus to be spread among multiple taxonomic groups
if desired.

Even better is to recognize the explicit link From Bbb Zed to Aaa (by
real children or group declaration) and therefore disable any implicit
shadow link (by name or observations.csv chain) from Bbb Zzz to Bbb.

But this gets more complicated if Ccc and Ddd are implicitly in the
same family (Ccceae) but explicitly are assigned to different families
(Ccceae and Ddceae).  A direct implicit link from Ccc/Ddd to the
family is handled fine, but what if the first indirect link from
Ccc/Ddd is to the tribe level (between genus and family)?  They would
then share the tribe and be confused about which family the tribe is a
member of.  The txt would need to declare an explicit tribe group to
prevent this problem.  Or a much more difficult solution is to build
the implicit chain from top to bottom while also passing properties
down the chain; any rank without a property (e.g. tribe) is skipped.


For performance, keep track of which taxonomic chains have already
been processed and don't reprocess them.  This relies on the knowledge
that each time a taxon is seen in observations.csv, the same taxonomic
chain is presented (with no holes).  I could prevent repeats based on
the taxon ID of the observation, but even better is to track
'taxon_chain_complete' for each page in the chain.  In this way, we
can bail out in the middle if, e.g., the species is a new observation,
but we've already completed the chain from the genus level.


photo_requires_color
color_requires_photo
*obs_requires_photo
obs_requires_color
requires_color


bad ideas:

Rather than forcing certain pages to list their full hierarchy in the
HTML, have a link between each normal key/listing page and its full
hierarchy.


Add a property 'create_from_obs' which creates a real page from any
observed taxon.  This property short circuits observation promotion
since the observed taxon will be turned into a real page, although
'ignore names.yaml' is still respected.  Outside observations are not
included, which means that shadow pages created by local vs. outside
observations must be distinguished.  A separate 'link' property is
needed to link a created low-level page to a higher-level page.  Extra
properties may also be needed for checking page relationships.


flag_no_sci: self-below ... makes no sense because the property only
applies to ranked pages with a scientific name, so it can never check
pages without a scientific name.

flag_no_com: self-below ... not worth implementing if I never use it.

--

I call hide_ac() when the forward/back button is used to change pages.
Should I also clear the search field?

Add manual links to the color pages from the flowering plants page.

When listing my observations for a taxon, make links to parks
&q=Henry+Coe
and months
&month=4
?

Use the representative jpg in a circular mask as the home link icon?
img.home-icon ... border-radius: 50%;

Remove support for ',[digit]' child declarations.

G4 dimensions:
screen 120mm/68mm
Chrome browser area: 96mm/68mm => 1536x1080
40px = ~7.5mm = 120 actual pixels
16 actual pixels/mm

The home-icon can't be selected with the "tab" key (no keyboard
focus), presumably because of its absolute position.  Can I fix that?
Perhaps a negative margin on the scroll container?

test PWA service worker locally:
/cygdrive/c/Python37/python -m http.server
http://localhost:8000/

https://web.dev/customize-install/

On the phone:
test entering airplane mode during cache update 
test cached pages while in airplane mode
test layout of swi buttons & text
test install
test speed of download and slowdown of browsing during download


cache warnings:

Track whether the cached URLs are complete.  This is an extra flag in
indexedDB.  It is marked 'false' when a cache update starts and
changed to 'true' when a cache update completes successfully.  It is
erased when the caches are cleared.  Note that it only describes the
cache contents without regard to the current manifest.

If the complete flag is false, fetches default to online and fall back
to offline.  If full support for this is difficult, skip the offline
fall back.

If the complete flag is true, fetches default to offline and fall back
to online when a cached page isn't found.

When the cache is out of date, put a yellow warning hazard symbol
(exclamation mark in triangle) in the upper right just under the
search bar:
- the complete flag is true and updating === false
  (cache is not updating nor up to date)
This can only occur while online or intermittently online.  It could
be annoying if the initial load of sw.js completes online, but
connectivity is not sufficient or data is too expensive to update the
cache.

When the cache is being pressed into service, use a red hazard symbol:
- the complete flag is false, but an online fetch has failed
This should only occur while offline or intermittently offline.  That
hazard symbol may be annoyingly persistent, but it's your own fault
for leaving the cache incomplete.

A red warning hazard symbol is also used when the cache is
surprisingly incomplete:
- the complete flag is true, and an offline access has failed.
This should only occur if I screwed up caching or if the user has
manually messed with the cache (or if the browser has discarded some
cache contents, but apparently not all?).

Clicking the hazard symbol takes you to the home page (targeting the
'Use it Offline' section) and removes the hazard symbol from the page
corner for as long as sw.js remains loaded.  (The yellow hazard is
dismissed for a minimum of a week by adding a timestamp to indexedDB.)

On the home page, at the top of the 'Use it Offline' section, a new
paragraph appears when there's a hazard along with the corresponding
hazard symbol.  This appears even if the corner hazard symbol has been
dismissed.  It is removed only when sw.js is reloaded or when the
cache status changes.

Green: The Guide is operating offline.  You will be kept informed when
an update is available.  [icon is home-icon.png]

Yellow: The Guide is operating offline.  An update is available
whenever you are ready.

Red2: Some files have gone missing from the offline copy.  Connecting
online for those files. -- yes; should be detected during cache
validation.  If any fundamental files are missing, clear offline_ready
and the indexedDB (so a refresh picks up a coherent set).

Red3: Some files are missing from the offline copy.  Oops, that's my
fault.  Check back for updates. -- no; can only be detected during
user fetch.  Danger: browser may try to fetch unreferenced files,
e.g. {root}/favicon/ico.  Or user could have used an old or otherwise
invalid URL.


Progress indicator should be better.  Perhaps...
a bar/line with colors:
green is how much is kept from the previous version.
yellow is how much is needed for the new update.
But what color for data that has been loaded for the new update,
but not yet 'installed'?  Black?  Or use black (or gray) for previous,
and green for newly loaded?

Note that a comparison of the old url_to_base64 to new_url_to_base64
tells us the original amount of data that we had before the current
update started.

For advanced understanding, perhaps two bars, one showing the total
cache usage, and another zoomed in to show the current transfer.
One bar above the status text (100% of the remaining window width),
the other below.  Light/fine gray/colored lines linking the zoomed
section to its excerpt.
https://stackoverflow.com/questions/51654061/zero-stroke-width-in-svg

Or make a real, opaque (fancy-shaped) progress bar the full width of
the viewport above or below the update button and status.

It might be more obvious with boxy bars at top and bottom, with
slanted shapes connecting them.

Existing data has a black bar, but no slanty color (and it would be
0-width in the zoomed section, anyway).

status = 0.0 + 0.7 / 643.5 MB ?  Ugh.

In this case, +0.7 / 1.3 MB corresponds to the zoomed bars, so
adjusting the text vertically to ~align with that part of the bar
might work.


increase margin to 20+ MB?  But increasing the margin might also make
the sw.js process larger unless I split things up somehow.


Have an offline option for 'no full-size photos', in which case links
to photos/... are re-directed to thumbs/...

Support auto-updates based on NetworkInformation.type?
The user still needs to manually start the web app, though, so it
doesn't seem useful.

Create a page that links to the most common wildflowers bay-area
wildflowers.  (Does this screw up glossary ownership?  Might need to
check for "compatible" glossary ownership [one a parent of the other]
rather than "same".)

What are the implications that the service worker is not used(?) on a
shift-refresh?


Advanced: minimize sw.js.  E.g. terser (requires node.js/npm).

Super advanced: put as much work as possible in a separate (worker?)
script so that the automatic fetches of sw.js are as minimal as
possible.


Do something better on a hard refresh (shift-F5).  Although
navigator.serviceWorker.controller is null, I can get the active
service worker by reading the 'active' value after registration.  Note
that a refresh of any site page in another tab/window triggers a
'controllerchange' and sets the navigator.serviceWorker.controller
value.


"Caution: There may be other species of this genus not yet included in
this guide." should be under the control of a property.  This other
property may or may not be used in the same places as
flag_obs_promotion_without_x.

list_hierarchy doesn't preserve the order from the txt file.  This is
documented, but not ideal.  Only auto-added children should be
re-ordered by default.

Print the count of observed taxons via some keyword, e.g. key_taxons.
Not a property; it applies only to its page, and it is replaced in place.

'No scientific name given for the following pages' should be an
optional error.

The various error-checking properties should also allow them to be
warnings (or info or disabled?).  E.g. use warn_foo to turn foo into a
warning, or no_foo to disable foo.

Checking properties should name the property (and its source txt?)
when printing a message.

Extend [example,<suffix>] to support [example:name,suffix], e.g. to
support example photos from deeper descendents (e.g. brush-footed
butterflies to variable checkerspot,6).

Reduce console logging from Javascript.

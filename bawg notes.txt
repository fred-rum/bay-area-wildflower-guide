Make new chris-nelson GitHub account and move the BAWG there.
Rename indexedDB to bawg_db (no version #)
Rename cache to bawg_cache (no version #)

>Make separate pages (and links) for flower lists (by color and "all")
with names only (for bandwidth saving) and photos only (for showing off).

Print errors:
  *no color listed
  *listed color not supported
  *broken photo
  no scientific name for leaf page
  multiple scientific names from observations.csv

###############################################################################

favicons generated by:
https://realfavicongenerator.net/

how to mass rename files:
for f in *.jpg; do git mv "$f" "$(echo $f | sed 's/-\([-0-9]*\)\.jpg$/,\1.jpg/')"; done

###############################################################################

clip-art icon source:
https://icon-library.com/png/148553.html

###############################################################################

Create a script to help copy new and changed files to a portable device.
  Copy new and modified files to a new (and git-ignored) folder,
    ready for the user to copy them over using Windows Explorer.
  Record the timestamp of all files to a (git-ignored) database
    to be used next time for identifying new and modified files.
  Deleted files won't be deleted, but they won't cause any harm.
  Include top-level files that should be copied if they are modified,
    e.g. index.html, bafg.css, search.js, pages.js
  Perhaps allow an argument with a date so that all files modified
    after that date are copied in case the database gets screwed up.
  (Explorer displays the photo creation date, but the file modification
    data is still correct internally.)

Should autogenerated families be structured more like top-level lists
(with a complete indented hierarchy)?

Put month info in table format with bar chart.
Put month info side by side with park info (depending on display width?)

/cygdrive/c/Python37/python -m cProfile -s cumtime src/bawg.py | less

Add (optional) color info for unobserved flowers?
How would that be presented?  (border on CalPhoto placeholder?)

Make links up to the key (or any other parent) use an anchor position
that highlights the child's section of the key, similar to the
glossary.  (May require similar positioning tricks.)

Have a way to link from txt to the key to a flower (e.g. for
rough-fruited buttercup in buttercups).
E.g. {-buttercups#rough-fruited buttercup}

If all modified pages are under a single modified parent (excluding
"all" and color lists), bring up that parent page automatically.  (Or
simply list it first, or list the modified pages hierarchically.
Might be able to reuse the html generation for color lists.)

Support color:none for non-flowering plants.  Allow it to be used at
an upper level of hierarchy, from where it automatically propagates
downward through the tree.  (Should I also allow propagation for other
colors?  It could come in handy, e.g. for a genus that is always the
same color.  But it would also make it easy to be sloppy and not
verify the correct color of everything.)

For a line that begins with '[', include an automatic h3 or lower
format on the remainder of the text line.  Use increasing header
numbers based on the bracket depth.  Line breaks remain <br/>.
Recognize this and continue the header, or require that the line be
run together with <br/> in the middle?

Parts of a pea flower:
https://en.wikipedia.org/wiki/Papilionaceous_flower#/media/File:Sesbanea_bispinosa,_crop.jpg

The banner is a single petal, but a crease along its midline may give
the appearance of two petals fused at the edge.


sea muilla:
perianth parts (no obvious corolla/calyx separation)
sepals (in bud, but opening) (no calyx tube)
filaments, anthers, pollen
ovary, style, stigma
pedicels
bracts
peduncle

milk maids:
petals
sepals

buttercup:
petals
sepals
pedicels
bracts
peduncle
anthers
pistil hard to see

sun cup:
petals
sepals
pedicel
anthers, filaments
stigma, style hidden
bracts out of view

field bindweed (2 photos)
petals
calyx (sepals indistinct)
pedicel
ovary/style/stigma
filaments/anthers

yellow mariposa lily: (2 photos; bawg photos are good)
petals
sepals
anthers, filaments
stigma, ovary
pedicel
no bracts

pale flax
good side view down to bracts
top view shows all the parts, but is too crowded to label


Add glossary entries to replace as many Jepson terms as I can.  If I
can get all of them, then perhaps I can make use of a Jepson term an
error.


Apply standard page substitutions on glossary pages, e.g. blank lines
to <p/>.

Add inflorescence shape definitions for sedges.  (Possibly share the
glossary with grasses, but probably not.)


Detect when a glossary term is defined twice in the same file (or
definition) (e.g. a typo).

Allow iNaturalist taxon ID to be specified in txt since iNaturalist
fails for shared genus names, e.g. onions (Allium).

Separate surprise_obs into multiple parts:
  species that don't have a page despite there being a genus page
    (or should it be all plant species that don't have a page?)
    (includes subspecies if the species page is missing.)
  subspecies that have a common name and a genus page (or are plants),
    but no page.
  subspecies that don't have a common name but are under a species
    for which subspecies are listed.


It'd be nice to link to a section of glossary words with the selected
one highlighted.  E.g. clicking "pedicel" would link to "Parts of a
flower" (highlighted in pale gray) with the "pedicel" entry
highlighted in yellow partway down the page.  This would require
Javascript for the yellow highlighting using extra information in the
URL, e.g. flower%20glossary.html?term=pedicel#parts+of+a+flower.  A
mobile screen is often too small for the section (especially if it
includes figures, but even without them).  Is some other solution
possible to indicate that the linked term is part of a section?

Now that glossary terms are flagged when used out of place, try moving
many of the plant glossary entries to the flower glossary.  Perhaps a
command-line arg could flag glossary terms that are never used in the
'plant glossary' context.


Use img property alt="" to indicate to blind users that a description
of the photo is not helpful?

I've removed the search penalty for autopropagated and unobserved pages.
I should also order them lower in pages.js.


Make the hierarchy more generic to fit anyone's taxonomic priorities:

'is_top' marks a page as being the top of a hierarchy.  Any
descendants of this page or pages that list this one as a higher-level
group are considered part of its hierarchy, so they won't be assigned
a hierarchy as per below.

'default_ancestor' marks a page as being the top of a hierarchy, *and*
any hierarchies that don't have an 'is_top' root are considered to be
part of its hierarchy.  Only one page can be marked
'default_ancestor'.  Does *not* imply 'is_top'.  E.g. flowering plants
may be the 'default_ancestor' while being under vascular plants, etc.

When checking ancestor properties, a page searches up through all
parents and also through all resolved groups from observations.csv.
In addition, a variety/subspecies is deemed to be a member of its
species, and a species is deemed to be a member of its genus,
regardless of observations.csv entries.

'create: <rank>' allows descendants to be added at the specified rank,
e.g. 'create: family'.  Pages are thus created automatically from
observations.csv.  Implies 'list: <rank>'.  This may be the hardest
property to handle in order to build a hierarchy in the correct order.
Perhaps iterate through each rank from bottom to top.  For each top of
hierarchy, check if it can and should create a page at the current
rank, and then do so.  (can = has a resolved group; should = has an
ancestor among resolved groups with the necessary 'create' property.)
At the same time, add parent/child relationships based on 'create',
'list', and 'hierarchy'.

'list: self' marks a page to allow children to be added via group
identification.  Otherwise, a group with incomplete children flags an
error.  'list: <rank>' allows children to be added to all descendants
that are the specified rank.

'require: <rank>' requires descendants below the specified rank to
have an ancestor at the specified rank, e.g. 'require: family'
requires that all flowers have a family.  Often accompanies but does
not require 'create: <rank>'.  If 'create: <rank>' is not specified,
the appropriate hierarchy must be created by hand.

'complete: <rank>' requires that any descendant page of the specified
rank must have as descendants all pages under that page's group.
I.e. if a page is a member of a 'complete' page, it must be an
explicit descendant.  Additionally, if at least two pages exist for a
group of the specified rank, the page for the group must exist.
E.g. 'complete: genus'

'hierarchy: self' marks a page to have its whole hierarchy listed.
Implies 'list: self' (below)?  'hierarchy: <rank>' is less useful to
me, but could perhaps be supported if easy.

'membership: self' causes all descendants to list themselves as a
member of the page.

'membership: <rank>' causes all descendants below the specified rank
to list themselves as a member of their ancestor at the specified
rank.  E.g. 'membership: family'.

Suppress write_lists for hierarchy above genus, e.g. in flowering plants.


Create a function to easily compare ranks beyond just genus/species.
Flag an error for unknown ranks when the sci name is "[rank] [Name]".

When specifying <rank> as part of a property, <rank> can be a range,
e.g. 'genus-family'.  The range can be in either order,
e.g. 'family-genus'.  Additional ranks/ranges can be specified,
e.g. 'genus, species, subspecies'.  If a page doesn't have a rank
(e.g. because it doesn't have a scientific name), it is considered
part of a range if it has both a parent and a child within the range.

<rank> can also be 'self', which refers to the marked page's rank.  If
the marked page doesn't have an explicit rank (e.g. because it doesn't
have a scientific name), it still marks itself, but only for
properties that can be performed on a complete hierarchy
(e.g. 'membership'), not properties that require group identification.

Rank properties are searched from a page as follows:
  - Recurse upwards through the hierarchy, including all choices of parent.
  - If the property is found, return the specified rank range through the recursion.
  - Any page that is in the rank range and any assigned group that is in the rank range is added to a list that is also returned.
  - The final result is a list of names (of pages that don't exist) and/or pages (that do exist) and/or ranks that weren't found.
  - E.g. [('genus', <Page>), ('tribe', None), ('family', 'Roseaceae')]
  - The list is preferably in rank order.
  - The list can include the page that specifies the property.
  - The list can include the page that initiated the search.

How the list is used:
  - create:
    if the lowest-ranked page on the result list doesn't exist, it is created,
      and the top page of the existing hierarchy is added as a child.
    if the lowest-ranked page on the result list does exist,
      the top page of the existing hierarchy is added as a child
      (if it isn't the same page).
  - list: as the last sentence above for create.
  - require: throw an error if any ranks weren't found
  - complete:
    if any page on the result list doesn't exist, we note its name
      associated with the top page of the existing hierarchy below it.
      if its name was already associated with a different page, throw an error.
    if any page on the result list does exist, verify that it is the top page
      of the existing hierarchy.
    what should we do if no page is known for the indicated rank?
      throw an error seems best.  the text should at least declare the
      rank that is being completed by a lower group, even if there is no such
      page.
  - hierarchy: apply if the page itself is in the list (lowest ranked).
  - membership lists the page as a member of all existing pages in the list.


ryegrass's lists doesn't include 'other flowers' because it has
exactly one child with color 'other'.  That is dumb, and it should be
listed with color 'other' even if doesn't appear on the list page.


Format glossary ToC better so that it is clearly a part of the
"Glossary table of contents", especially when "plant glossary" is the
current glossary and thus bold and not linked.

To speed Javascript or CSS editing, allow a parameter to bawg.py to
reference src/search.js and src/bawg.css directly.  (But what about
index.html?)

Make the placeholder text in the search field a much lighter shade of
gray.


Support searches for "help", "bawg", "bay area wildflower guilde",
"contact me".


A subgenius eludes my script's ability to recognize.  Add 'genus' to
the exported taxon list to help resolve it.

Add support in find_property() for guessing genus and species group
ancestors based on partial names.


Move intelligence about 'higher ranks' into resolve_group()

Remove group_child_set, which is no longer used.

Restore support for checking that all families are identified under
flowering plants.


When a top page creates a new page, it can also create a page for
every higher rank for which pages get created.  (Or perhaps re-do the
search for the new page, in case there are hierarchy complications.)

If page creation/linking is enabled for any lower ranks, then pass the
property results down down into the children for processing.
(Except... what if a lower page in the hierarchy has its own
properties?)  It almost seems like I need to resolve_groups for any
pages that need it, then start from each property and work downward
through the hierarchy and shadow hierarchy.  Perhaps it is equivalent
to keep the current upward search from every page, but allow every
page on the path to create/link a page according the results passed
through it, and then mark every page along the path as complete.  Any
future search that hits that page immediately returns with the results
that remained when that page was done.


Current thinking:

Build a shadow tree so that I can search up or down.  Include real
pages (with or without a rank) and group placeholders.  A page without
a rank is ranked just below the lowest common ancestor of all
children, and that LCA is its parent.  Tree traversal can skip up
through the unranked page or traverse the normal group hierarchy
around it.

Nodes in the shadow tree can be looked up by iNaturalist scientific
name to facilitate creating links from observations.csv.
family_names.yaml allows a common name to be converted to a scientific
name in case a page declares a group by common name.  When a new node
is created, it checks for a corresponding page (by scientific name or
iNat sci name) and cross links it.  When a new page is created for a
group, it is also cross linked.

Properties are copied from the real tree and thereafter are associated
with the shadow tree.  Properties are pushed down through all child
paths to all applicable ranks (e.g. for 'create: family', it is pushed
to the family rank).  Note that for this purpose, the node only needs
to keep track of the property name; the rank is implied, and
alternative ranks for the property are not needed.

For performance, I could record the set of pages for each rank of each
property, but that doesn't seem necessary.

From lowest to highest rank, for each page that has a property, apply
that property.  E.g. for 'create', the page is created if it doesn't
exist, and a link is created from each child.  If the shadow child is
not real, continue descending the tree to find the first real child on
each path.

Because a tree can split and rejoin through an unranked page, the
above procedure could create a link to a page when it has a real
ancestor that already gets a link (or already has a link).  Possible
solution: create a set of links to be created without yet creating
them.  Then traverse up through the real hierarchy of each "child" and
delete that child from the set if it finds any ancestor also in the
link set (or already linked).  Only create links after trimming the
set in this way.


--

'-db test' causes txt, photos, glossary, and prev, html, thumbs to be
prefixed with 'test_'.  (Don't forget to add 'test_*' to
'.gitignore'.)  Populate test_txt with only a small set of files in
order to develop and test tree-building code.  (index.html will still
have links to the original locations, but that's easy enough to work
around, so a change to index.html doesn't seem necessary.)  Files from
the 'data' directory look innocuous, so their usage doesn't need to
change.  Perhaps I'll get some warnings about observed flowers not
having pages that I'll have to disable.

--
Linnaean Tree

The Linnaean tree (shadow hierarchy) is maintained using regular pages
that aren't necessarily output to HTML.  If a page exists purely for
the shadow hierarchy, it is not included in page_array, which keeps it
out of scans of "all pages".  The taxon tree relationship is
maintained in each page using a taxon_parent link and a taxon_child
set that are separate from the normal parent/child links.  A
taxon_parent or taxon_child may duplicate a parent/child link; any
code that casres can easily check whether a pointer exists in both
links.  A shadow page is marked as such upon creation with
shadow=True.  If the shadow page is later converted to a real page,
shadow is set to False, and the page is added to page_array.

Shadow pages can be looked up in sci_page, com_page, or isci_page as
usual.  Possibly shadow pages have reduced priority when there is a
common name conflict.

Whenever set_sci() is called for a page, its rank is determined from
its name.  Hopefully I've consistently used "spp." for genuses, so if
I ever get a weird one like "Esula" (a subgenus), I can set its rank
to None, the same as pages without a scientific name.

Whenever assign_child() is called for a page, we check for various
errors.  A circular loop or a child assigned twice is already checked.
Also check that the parent has a higher rank than the child.  (If the
parent doesn't have a rank, traverse all of its parents to find every
possible ancestor rank.  If the child doesn't have a rank, traverse
all of its children to find every possible descendant rank.  For these
purposes, taxon_parent and taxon_child are also traversed.  For
efficiency, only non-duplicate links are traversed.)  Note that a
circular loop is a special case of the search for an ancestor rank
that returns to the original page.

When a normal link is created with assign_child(), we also attempt to
create a shadow link.  If the parent and child each have a rank, then
the shadow link can be created right away.  If the parent does not
have a rank, then we traverse its ancestors and shadow_parent, and
create a shadow link from the child to the lowest-ranked ancestor
found on any path.  (It's conceivable that by accident or design, an
unranked page has different ranked ancestors.  Hopefully they're at
least in the same taxonomic chain, but at this time I don't plan to
check.)  If the child does not have a rank, then we traverse its child
and shadow_child links and create a shadow link from the parent (or
its lowest-ranked ancestor) to the first ranked descendant found on
each descendant path.  Note that at this time we don't create a shadow
link to or from an unranked page.

Shadow links (taxon_parent/taxon_child) are initially added between
pages by these causes:
- A normal link is created which also creates shadow links
- A genus/species group is implied by a species/subspecies name
- A group is declared in the txt (e.g. 'family: grasses')
- A taxonomic chain is read from observations.csv

A taxonomic chain from observations.csv is likely to be complete, but
the others are not.  (A taxonomic chain could be incomplete depending
on how I address discrepancies in the iNaturalist hierarchy.)  In
particular, some ranks may initially be skipped as the shadow tree is
built (e.g. because a subspecies is a direct child of a genus), but
then we attempt to add the skipped ranks to the tree later (e.g. from
observations.csv).  This situation can be recognized when we attempt
to create a shadow link, but the child already has a parent which is
not the one we're trying to link.  If the old and new parents have the
same rank, flag an error.  If the new parent has a lower rank than the
old parent, insert the new parent between the child and its original
parent.  (The old parent becomes the parent of the new parent.)  If
the old parent has a lower rank than the new parent (e.g. because the
txt specified the tribe group and then the family group), then instead
of adding the link from the child, we try to add the new parent as a
parent of the old parent (continuing to recurse as necessary).

Note that an iNaturalist group name can differ from my group name only
if I have a txt file for that page.  In that case, the page is created
with its canonical name, and data from observations.csv can find the
page via isci_page.  If a shadow page is created from observations.csv
(using an iNaturalist-supplied name), it may eventually get promoted
to a real page, but it can never have its name changed to something
different.  Note that a group declared in the txt is expected to use
my canonical name, not the iNaturalist name (although they can be the
same, of course).

After creating and linking all pages and shadow pages (i.e. after
reading observations.csv), some pages will be left without a parent or
Linnaean parent.  In simple cases such a page either has 'is_top' set,
or it wants to be placed under default_ancestor.  But there are
exceptions:

- A shadow page could have been created as a Linnaean ancestor of an
'is_top' page.  In this case, we don't want to place the shadow page
under the default_ancestor.  Instead, we want to propagate 'is_top' up
to the top of the Linnaean hierarchy.

- An unranked (real) page could find a closer ancestor that we'd
rather put it under than the default ancestor.

- A combination of these would have an unranked 'is_top' page in which
a ranked child has Linnaean parents.  Whether or not the unranked
'is_top' page can find a closer ancestor, it wants to make sure that
its children's Linnaean ancestors are marked 'is_top'.

We can mix the order of propagating 'is_top' up (or down) relative to
resolving unranked pages' ancestors.  I.e. both processes can be mixed
in one pass over all (real) pages.  A second pass can then assign the
default_ancestor where needed.  Ultimately, we want every page without
a Linnaean parent to either have 'is_top' set or be assigned the
default_ancestor.

Pass 1: propagate 'is_top' and resolve unranked pages' ancestors

If a ranked page has 'is_top', it is moved/copied to the top of its
Linnaean hierarchy.  Note that we don't really expect any pages along
the propagation chain to have a real parent, as that would imply that
'is_top' isn't placed optimally.  Perhaps flag a warning for this
case, and/or propagate into the real parents as well.  On the other
hand, multiple pages can propagate 'is_top' to the same shadow
ancestor, and that's fine.

If an unranked page has no Linnaean parent, then it is resolved using
the following process.

If a (real) page has no rank and no Linnaean parent then we try to
"resolve" it to have a Linnaean parent.  This parent is defined to be
the lowest common child ancestor (LCCA), i.e. the lowest-ranked
Linnaean ancestor shared by all real children.  (Note that an unranked
page shouldn't have any shadow children).  For each real child, we
traverse its Linnaean ancestry and return a set of all of its
ancestors.  We take the intersection of all children's sets to get the
set of common child ancestors (CCA).  The lowest-ranked ancestor in
this set is the LCCA.

If the children do not share any ancestors (including the case where
some child has no Linnaean parent at all), then the CCA set is empty,
and no LCCA is assigned as the Linnaean parent.

Example:
'nifty flowers' has children 'Clarkia spp.' and 'Taraxia ovata'.
'Clarkia' has ancestors 'family Onagraceae', 'flowering plants', etc.
'Taraxia ovata' has ancestors 'Taraxia spp.', 'family Onagraceae',
  'flowering plants', etc.
The CCA are 'family Onagraceae', 'flowering plants', etc.
The LCCA is 'family Onagraceae'.

If we need to get the ancestor set of an unranked child with no
Linnaean parent, we recurse and resolve the child, then continue with
the original resolution.  If we need to get the ancestor set of an
unranked child that has a Linnaean parent, then we must have already
resolved it, and we can gets its ancestor set without needing to
resolve it again.

When resolving a ranked child without a shadow parent, we return the
empty set.  Either we're in an 'is_top' situation, in which case we
expect the hierarchy to already be sufficiently complete without
assigning Linnaean ancestors, or we're not, in which case we'll end up
assigning the default_ancestor to both the ranked child and the
unranked page that we're trying to resolve.

In case we end up not finding an LCCA at any level of recursion, we
pass the 'is_top' value down to each child as we recurse into it.  The
child then passes 'is_top' up the chain as it gets its ancestor set.
As a convenient side effect, if we *do* find an LCCA, then we know
that it has already received 'is_top' from all children.

Pass 2:

If a page (real or shadow) has a rank but doesn't have a Linnaean
parent, and 'is_top' isn't True, then we set its Linnaean parent to
the default_ancestor page.


Once the shadow tree is entirely built, the properties can be
processed...

All (real) pages are scanned, and each property is pushed down into
all descendants.  Properties only apply to 'self' and to ranked
pages, but they are also pushed through real descendants (not just
shadow descendants) since some unranked pages won't have shadow
descendants.  For efficiency, a shadow descendant isn't traversed if
it duplicates a real descendant.

A 'self' property is not pushed down at all.  A ranked property is
left on any page with a matching rank.  This is recorded differently
than the original property dictionary (which included a set of ranks
for each property), but is simply the existence (or not) of each
property on each page.  (E.g. call it 'prop_set', as opposed to
'prop_ranks'.)

While pushing down properties, a descendant page may declare its own
ranks for a property that is being pushed down.  By default, the
property takes the union of the descending ranks and the declared
ranks.  However, if the declaration includes 'replace', then only the
declared ranks are applied to that page or below.  'replace' can
appear with no ranks specified, in which case propagation ends for the
property.  E.g. 'create: replace'.  This 'replace' concept might not
be terribly useful since for properties like 'create' or 'no_create'
or 'no_orphan', the most likely place to want to replace the
properties is on the shadow page that applies the property, but shadow
pages can't declare their own properties.  Does it make sense to
instead have another set of property overrides that apply to the
descendant end of a link?  E.g. 'no_no_orphan' on an individual
species would exclude it from a 'no_orphan' check applied to its
genus.  In this case, instead of naming properties things like
'no_orphan', 'flag_orphan' may be better.

For each rank from lowest to highest, all pages and shadow pages are
scanned.  I.e. we need an array of all pages, not just real pages.

If a ranked (real or shadow) page has a 'create', 'link', 'no_create',
or 'no_link' property, then a set of descendants to (potentially) link
to the page is created.  The shadow tree is traversed to find the
first 'real' descendant along each path.  (The real tree isn't
traversed because that's a link that already exists and doesn't need
to be re-created.)  Once a real descendant is found, we check to see
if it has a real parent which is in the same Linnaean tree.  This can
only occur if the real parent is unranked (since a ranked parent would
have been found first in the descent).  So, once a real descendant is
found, we check the Linnaean ancestor chain of each of its real
parents.  If the ancestor chain includes the original shadow page,
then the real parent (or perhaps one of its ancestors) will get a
link, and there's no need to create another one to lower in the tree.

I.e.
- Start the search from ranked page 'X' with the applied property.
- From 'X', find each Linnaean descendant, 'Y'.
- From 'Y', find each real parent, 'Z'.
- If no 'Z' has Linnaean ancestor 'X', then a link can be created
  from 'X' to 'Y'.

The action to take depends on the property, whether the page it
applies to is real or shadow, and the number of links that can be
created from it.

In all cases below where links are created, the child pages are sorted
so that pages with more observations are linked first.

For 'obs' on a shadow page, an error is flagged if the taxon appears
in observations.csv (as long as it is in the bay area and not in
ignore species.yaml).

For 'photo' on a real page, an error is flagged if the taxon is
observed and the page does not have a photo (directly on the page or
propagated up from a descendant).

For 'create' on a shadow page with at least one pending link, the page
is promoted to 'real', and the links are created.  If the shadow page
has no real descendants and thus can't create any links, the page must
have been created from observations.csv for a section of hierarchy
that we don't have pages for.  A later property can check for this
condition if we care.

For 'create2' on a shadow page with at least *two* pending links, the
page is promoted to 'real', and the links are created.  If only one
link is possible (i.e. we'd create a rather boring extra level of
hierarchy), nothing is done.

For 'create' or 'create2' on a real page, nothing happens, no matter
how many links could potentially be created.  A 'link' can create
these links as desired, or a 'no_link' property can complain about the
missing links.

When the 'create' property promotes a page to 'real', if the page also
has the 'common' property, then the common name must be defined in
family_names.yaml (or 'n/a').  For any explicitly created page, I
assume that the

For 'common' on a shadow page, if the page is promoted to a real page
by the 'create' property, then the common name must be defined in
family_names.yaml.  (A common name from observations.csv is
insufficient.)  Regardless of the 'common' property, if the common
name is given, it is applied to the promoted page.

For 'link' on a real page (with at least one pending link), the links
are created.

There is no 'link2' property.  If the page exists, there's no reason
not to link to it.

For 'link' on a shadow page, nothing happens.

For 'no_create' or 'no_create2' on a shadow page, an error is flagged
if the corresponding number of links could be created.

For 'no_link' on a real page, an error is flagged if any links could
be created.

For 'no_orphan' on a shadow page, an error is flagged if all Linnaean
descendants that are real do not share a common ancestor via real
links.  (If there is only a single real Linnaean descendant, it is its
own ancestor, which is fine.)  This is a bit looser than 'no_create2';
it doesn't require that the common ancestor is the page with the
property applied, but instead only requires that there is a common
ancestor somewhere.  Note that this check is run before creating links
for higher ranks, so the descendants won't trivially share a common
ancestor such as 'flowering plants'.  Should the check for Linnaean
descendants stop at the first real page on each path (relying on
'no_link' to find orphans below that page) or continue all the way to
the bottom?

I'll have the 'flowering plants' page assert 'no_orphan: genus' and
'no_link: genus-below'.  Thus, if a genus has at least two members, I
expect a txt page for that genus.  And if a genus or species has a
page, then all members of that genus/species must have an explicit
link from that page.  Note that this allows a genus page to directly
link to multiple varieties of the same species without an intermediate
species page if desired.  If I wanted to require a species page as
well, I could instead assert 'no_create2: genus-below'.

Other properties are handled as follows:

While 'require' is being pushed down to matching ranks in the
hierarchy, an error is flagged if it the tree traversal skips over a
rank specified by the property.  E.g. for 'require: family', an error
is flagged if a genus is found in the tree (e.g. as a descendant of
the default_ancestor), but its family isn't known.  This could
potentially flag an error when there is no real page below the missing
group, but the lower-ranked shadow page could only have been created
by observations.csv, which I expect to be complete.  There is no error
if the descendants peter out without reaching a required rank.

If a page is marked 'hierarchy', then its entire hierarchy is output
after any txt in the page.  The expectation is that the hierarchy
comes from automatically generated links, not explicit children.  To
support this, links created by the 'create' or 'link' properties don't
add the link to the txt (only to the child set) if the page has the
'hierarchy' property.

While emitting the HTML for a page, we search all shadow ancestors for
the 'member_link' property.  If an ancestor exists but isn't an
immediate real parent, the page is listed as a 'member of' the
ancestor (including an HTML link to the page).

Similarly, if an ancestor has the 'member_name' property and is *not*
'real', the page is listed as a 'member of' the ancestor (obviously
not including an HTML link).

When checking the shadow hierarchy, some pages (e.g. needle grasses)
might confuse the checks by including species of multiple genuses
while pretending that they are part of a single genus (e.g. because
Jepson classifies them that way).  Perhaps a page can specify a list
of scientific names that it satisfies the requirements for.  And
perhaps that list of names can be included as the "scientific name" on
the page (although only one would be included in links), and all of
its names can be included in pages.js.



When a 'genus' page includes species of multiple genera, it creates a
conflict in which the 'genus' page thinks it must be a member of
another genus.  The simple solution is to simply remove the scientific
name from the page.  But that sometimes means changing the name of the
txt file, as well.

asci: [name] specifies an alternative scientific name that maps to the
same page.  E.g. if the page for 'Aaa spp.' has 'asci: Bbb spp.', then
a child species of 'Bbb Zed' will look for its taxonomic parent 'Bbb'
and find it on page 'Aaa'.

Instead of asci, a more flexible solution would be to allow groups
declared in the txt to override the species/genus guesses from the
name.  E.g. if Bbb Zed declares that is a member of genus Aaa, then it
won't try to add Bbb as a Linnaean parent.  This could also
potentially override the taxonomy read from observations.csv if so
desired.  Requiring a genus group to be repeatedly declared for every
species member is slightly painful, but it's a useful reminder that
the user is doing something unorthodox.  In any case, this scheme
allows members of a genus to be spread among multiple taxonomic groups
if desired.

Even better is to recognize the explicit link From Bbb Zed to Aaa (by
real children or group declaration) and therefore disable any implicit
shadow link (by name or observations.csv chain) from Bbb Zzz to Bbb.

But this gets more complicated if Ccc and Ddd are implicitly in the
same family (Ccceae) but explicitly are assigned to different families
(Ccceae and Ddceae).  A direct implicit link from Ccc/Ddd to the
family is handled fine, but what if the first indirect link from
Ccc/Ddd is to the tribe level (between genus and family)?  They would
then share the tribe and be confused about which family the tribe is a
member of.  The txt would need to declare an explicit tribe group to
prevent this problem.  Or a much more difficult solution is to build
the implicit chain from top to bottom while also passing properties
down the chain; any rank without a property (e.g. tribe) is skipped.


For performance, keep track of which taxonomic chains have already
been processed and don't reprocess them.  This relies on the knowledge
that each time a taxon is seen in observations.csv, the same taxonomic
chain is presented (with no holes).  I could prevent repeats based on
the taxon ID of the observation, but even better is to track
'taxon_chain_complete' for each page in the chain.  In this way, we
can bail out in the middle if, e.g., the species is a new observation,
but we've already completed the chain from the genus level.


photo_requires_color
color_requires_photo
*obs_requires_photo
obs_requires_color
requires_color


bad ideas:

Rather than forcing certain pages to list their full hierarchy in the
HTML, have a link between each normal key/listing page and its full
hierarchy.


Add a property 'create_from_obs' which creates a real page from any
observed taxon.  This property short circuits observation promotion
since the observed taxon will be turned into a real page, although
'ignore names.yaml' is still respected.  Outside observations are not
included, which means that shadow pages created by local vs. outside
observations must be distinguished.  A separate 'link' property is
needed to link a created low-level page to a higher-level page.  Extra
properties may also be needed for checking page relationships.


flag_no_sci: self-below ... makes no sense because the property only
applies to ranked pages with a scientific name, so it can never check
pages without a scientific name.

flag_no_com: self-below ... not worth implementing if I never use it.

--

I call hide_ac() when the forward/back button is used to change pages.
Should I also clear the search field?

Add manual links to the color pages from the flowering plants page.

When listing my observations for a taxon, make links to parks
&q=Henry+Coe
and months
&month=4
?

G4 dimensions:
screen 120mm/68mm
Chrome browser area: 96mm/68mm => 1536x1080
40px = ~7.5mm = 120 actual pixels
16 actual pixels/mm

The home-icon can't be selected with the "tab" key (no keyboard
focus), presumably because of its absolute position.  Can I fix that?
Perhaps a negative margin on the scroll container?

test PWA service worker locally:
/cygdrive/c/Python37/python -m http.server
http://localhost:8000/

https://web.dev/customize-install/

On the phone:
test entering airplane mode during cache update 
test cached pages while in airplane mode
test layout of swi buttons & text
test install
test speed of download and slowdown of browsing during download


cache warnings:

Track whether the cached URLs are complete.  This is an extra flag in
indexedDB.  It is marked 'false' when a cache update starts and
changed to 'true' when a cache update completes successfully.  It is
erased when the caches are cleared.  Note that it only describes the
cache contents without regard to the current manifest.

If the complete flag is false, fetches default to online and fall back
to offline.  If full support for this is difficult, skip the offline
fall back.

If the complete flag is true, fetches default to offline and fall back
to online when a cached page isn't found.

When the cache is out of date, put a yellow warning hazard symbol
(exclamation mark in triangle) in the upper right just under the
search bar:
- the complete flag is true and updating === false
  (cache is not updating nor up to date)
This can only occur while online or intermittently online.  It could
be annoying if the initial load of sw.js completes online, but
connectivity is not sufficient or data is too expensive to update the
cache.

When the cache is being pressed into service, use a red hazard symbol:
- the complete flag is false, but an online fetch has failed
This should only occur while offline or intermittently offline.  That
hazard symbol may be annoyingly persistent, but it's your own fault
for leaving the cache incomplete.

A red warning hazard symbol is also used when the cache is
surprisingly incomplete:
- the complete flag is true, and an offline access has failed.
This should only occur if I screwed up caching or if the user has
manually messed with the cache (or if the browser has discarded some
cache contents, but apparently not all?).

Clicking the hazard symbol takes you to the home page (targeting the
'Use it Offline' section) and removes the hazard symbol from the page
corner for as long as sw.js remains loaded.  (The yellow hazard is
dismissed for a minimum of a week by adding a timestamp to indexedDB.)

On the home page, at the top of the 'Use it Offline' section, a new
paragraph appears when there's a hazard along with the corresponding
hazard symbol.  This appears even if the corner hazard symbol has been
dismissed.  It is removed only when sw.js is reloaded or when the
cache status changes.

Green: The Guide is operating offline.  You will be kept informed when
an update is available.  [icon is home-icon.png]

Yellow: The Guide is operating offline.  An update is available
whenever you are ready.

Red2: Some files have gone missing from the offline copy.  Connecting
online for those files. -- yes; should be detected during cache
validation.  If any fundamental files are missing, clear offline_ready
and the indexedDB (so a refresh picks up a coherent set).

Red3: Some files are missing from the offline copy.  Oops, that's my
fault.  Check back for updates. -- no; can only be detected during
user fetch.  Danger: browser may try to fetch unreferenced files,
e.g. {root}/favicon/ico.  Or user could have used an old or otherwise
invalid URL.


Progress indicator should be better.  Perhaps...
a bar/line with colors:
green is how much is kept from the previous version.
yellow is how much is needed for the new update.
But what color for data that has been loaded for the new update,
but not yet 'installed'?  Black?  Or use black (or gray) for previous,
and green for newly loaded?

Note that a comparison of the old url_to_base64 to new_url_to_base64
tells us the original amount of data that we had before the current
update started.

For advanced understanding, perhaps two bars, one showing the total
cache usage, and another zoomed in to show the current transfer.
One bar above the status text (100% of the remaining window width),
the other below.  Light/fine gray/colored lines linking the zoomed
section to its excerpt.
https://stackoverflow.com/questions/51654061/zero-stroke-width-in-svg

Or make a real, opaque (fancy-shaped) progress bar the full width of
the viewport above or below the update button and status.

It might be more obvious with boxy bars at top and bottom, with
slanted shapes connecting them.

Existing data has a black bar, but no slanty color (and it would be
0-width in the zoomed section, anyway).

status = 0.0 + 0.7 / 643.5 MB ?  Ugh.

In this case, +0.7 / 1.3 MB corresponds to the zoomed bars, so
adjusting the text vertically to ~align with that part of the bar
might work.


increase margin to 20+ MB?  But increasing the margin might also make
the sw.js process larger unless I split things up somehow.


Have an offline option for 'no full-size photos', in which case links
to photos/... are re-directed to thumbs/...

Support auto-updates based on NetworkInformation.type?
The user still needs to manually start the web app, though, so it
doesn't seem useful.

Create a page that links to the most common wildflowers bay-area
wildflowers.  (Does this screw up glossary ownership?  Might need to
check for "compatible" glossary ownership [one a parent of the other]
rather than "same".)

What are the implications that the service worker is not used(?) on a
shift-refresh?


Advanced: minimize sw.js.  E.g. terser (requires node.js/npm).

Super advanced: put as much work as possible in a separate (worker?)
script so that the automatic fetches of sw.js are as minimal as
possible.


Do something better on a hard refresh (shift-F5).  Although
navigator.serviceWorker.controller is null, I can get the active
service worker by reading the 'active' value after registration.  Note
that a refresh of any site page in another tab/window triggers a
'controllerchange' and sets the navigator.serviceWorker.controller
value.


"Caution: There may be other species of this genus not yet included in
this guide." should be under the control of a property.  This other
property may or may not be used in the same places as
flag_obs_promotion_without_x.


list_hierarchy doesn't preserve the order from the txt file.  This is
documented, but not ideal.  Only auto-added children should be
re-ordered by default.

Also good is if list_hierarchy doesn't suppress normal activity.
Instead, a child and its key is output normally (including the larger
photo when appropriate), and then the descendent hierarchy is emitted.

Color subsets should still be re-ordered by observation count.


Print the count of observed taxons via some keyword, e.g. key_taxons.
Not a property; it applies only to its page, and it is replaced in place.

'No scientific name given for the following pages' should be an
optional error.

The various error-checking properties should also allow them to be
warnings (or info or disabled?).  E.g. use warn_foo to turn foo into a
warning, or no_foo to disable foo.

Checking properties should name the property (and its source txt?)
when printing a message.

Extend [example,<suffix>] to support [example:name,suffix], e.g. to
support example photos from deeper descendents (e.g. brush-footed
butterflies to variable checkerspot,6).

Reduce console logging from Javascript.

Make a check that a page at a specified rank is present if it has descendents.
I.e. if a page defaults to flowering plants, it must have a family.  E.g.
require_rank: family


Add a property to specify the default completeness of a taxon,
e.g. 'default_x caution: genus'.  A 'caution' is the same as
'unknown', but in bold text.  'fatal', 'error', and 'warning' and the
usual x/xx values are also permitted.  I'd want to assign multiple
values to propagate down to different levels; fortunately I think the
way the code works now, that will work as long as they're all declared
at the same level.  Possibly they need to be recorded in a list
instead of a dict.

It would be nice to include the unranked moths in the property range
from insects.  But perhaps overly difficult.


When printing trees, should a real child that is also a distant
Linnaean descendent be handled differently?

the first photo in a [] box is not vertically inset properly


create a page for rayless and near rayless (e.g. blow wives) yellow asters
  (similar to page for yellow daisy-like flowers)


Better support would be nice for multiple genuses (or other groupings)
on the same page (e.g. the genuses for blue dicks and ookows).
Currently supported via 'asci:', but it's unintutive to understand in
the script, and the page doesn't reflect the alternative names, nor
can you search for the alternative names.

Translate *text* on one line to <b>text</b>.


Should flowers like 'red hot poker' be included in the observations
even if marked 'cultivated'?  Otherwise I get confused and wonder why
it has a photo in the BAWG without any observations.  This would
require an exception to the flag properties, or perhaps a new flag.

Allow photos to have the same name flexibility as iNaturalist
observations.  E.g. ignore hyphens, plurals.

allow top of tree to have no glossary; move plant glossary to plants

rearrange docs into an easier-to-read LibreOffice/PDF document

move pickle files into a new 'pickle' directory

flag pages without parents that aren't marked is_top (see below item...)

assume is_top automatically if it has a scientific rank above flowers

instead of using default_ancestor, manually add 'ancestor:flowering
plants' to any flowers without an observations.csv entry, and use a
property to find unlinked pages.  But... properties can't propagate to
unlinked pages, so how would that work.  Unless there's a property
that says "every page must be linked to me", which isn't really a
property but something else.  In any case, "default_ancestor" is still
useful for a DB in progress, especially when everything is of the same
type.

If a page is above the genus level and has no photographed(?) children
(e.g. flesh flies), omit the count of observations that are "research
grade".

add properties to report disconnected links, e.g. 'flag_link', and use
it for everything that isn't flowering plants (since plants are linked
automatically).

Change "Glossary table of contents" to "Organization of glossaries" or
something else that makes it clear that there is more than one
glossary.

How to prompt for a PWA install when desired:
https://developers.google.com/web/updates/2019/05/mini-infobar-update
or 02. in:
https://www.creativebloq.com/features/9-amazing-pwa-secrets


Extend -tree <n> argument to allow a <taxon name> to be specified, and
the tree is printed for that page and its descendents.  And properties
are only output if 'props' is also specified.  Note that these extra
options are recognized as part of '-tree' and not a following option
because they do not start with a '-'.

Use casefold() instead of lower() for case-insenstive matching?
https://docs.python.org/3/howto/unicode.html#comparing-strings

And use normalize and fileurl() or whatever when setting the name.

Allow a com or sci name that was implied by the filename to be changed
by any other non-iNaturalist name source.  E.g. its priority is
'inat', 'file', or 'user'.  Or use the 4 values currently assigned in
com_priority.

Can I get rid of name_page?  It's unclear what it's protecting
against; perhaps a capitalized com name colliding with a sci name?

What do I need to support capitalized common names:
  is_sci() returns false if the name is in com_page
  Page.__init__() doesn't fail if the common name is capitalized
  any lookup of a common name is case insensitive
    (e.g. make a find_com() in place of 'in com_page')
  checking for collisions name_page should also be case insensitive

'set_name() failed for name' can also mean that a child declaration
without a scientific name couldn't find a match, so it tried to create
a new page and failed.

self.full() should report where the page came from (e.g. name.txt,
parent.txt, groups.yaml, observations.csv, etc.)

If Page.__init__() is called with name_from_txt, it shouldn't set the
name right away.  Instead it should leave the page nameless until
every other source of names has been exhausted.  Other name sources
(e.g. children declarations) check for a match with the page's
filename when calling find_page*().  Note that a match from name_page
is only allowed if the page has no names if it has a non-matching name
and an unset name (of the appropriate type, if necessary).  (If it has
a matching name, then we can't use that same name for the other name
slot.)

Ditch com_page vs. sci_page vs. name_page?  Nah.  com_pages are
allowed to collide, even if one of them has the same filename, whereas
a sci_page is not allowed to collide with a com_page, etc.

Disallow collisions between common names and scientific names.

Don't set the filename of a non-txt page until all sources of names
have been exhausted.  This isn't "necessary", but it makes naming
easier.  But it means that I can't use self.name as a generic debug
string.  (I should be using self.full() anyway.)

Rename self.full() to something more obvious debug-related,
e.g. self.dbg_name().

When a name is used by find_page1 (e.g. by a child declaration with
only one name), but we don't know if its a com or a sci name, then we
mark it.  This reserves the name so that it can't be squeezed out of a
spot later.  As soon as either slot gets a non-matching name, the
other slot gets the filename.

repl_child uses is_sci() to interpret a single name.  At the very
least, it should search with find_page1(), then only make a guess if
it has to create a new Page().  But if it needs to expand the genus
abbreviation, of course it is a scientific name.

-dir test/caps currently fails due to the above.

When a routine like repl_child creates a new Page() with a single
name, it would be nice if it could also leave undetermine what sort of
name it is.  That would require a new flag to Page() to distinguish a
known com/sci name from an indeterminate name.

Maybe instead of putting the indeterminate name in Page.name, it
should be in *both* com and sci.  So no "name" lookup is needed, and a
separate step isn't needed when one name is set.  On the other hand,
that would still fail without extra code when the indeterminate name
is entirely overwritten (e.g. the filename is ignored in favor of com:
and sci:).  And it doesn't make the code any more robust than
currently.

fix glossary for gall insects (allow multiple?)

when using Javascript search, if search string has an exact match including
  non-letter characters (e.g. "heart's"), use only those exact matches?

when searching, skip vowels if there are no other matches
  for approximate pronunciation match

flag pages with an automatic parent (i.e. placed in flowering plants)
  but I might need to allow families to be automatically placed
    unless I want to declare them manually
  on the other hand, families from observations will also know their
    flowering plant ancestor, and any others are easy enough to declare

get the common name from iNaturalist's API if the taxon is not directly observed
  this is useful for automatically constructing ancestor pages
add 'do member_name: genus, species' in life.txt
allow searches for a genus/species that only has a shadow page
  to find the lone(?) real child (as with an alternative name)

allow individual images to be annoted with a brightness value
  this allows photos to be fixed without a ~500KB commit
  CSS is 'filter: brightness(1.2);'
    add the style directly in the HTML for the thumbnail
    also add the style in Javascript for the photo gallery

should headings be a different color for keys, parents, unobserved taxons?

Support "personal notes", created with "note:[...]".
  highlight these so that they stand out for any relevent taxon
    (and child taxons?)

I probably need a method for proper citations, e.g. in case of link rot.
  Perhaps it could simply be a glossary!
    The glossary definition would then link to the resource, if available.
  But a website demands not just a description and link to the website,
    but rather a description and link to the individual page.
    And that's awkward in a citation format.
    Perhaps the (glossary) citation is to the website, which is then followed
      in the text by a linked description of the page.
      E.g. "California Herps (glossary link) has more tips for
        identifying alligator lizards in california (page link)."
  Examples:
    inline citation:
      (<a>Russo 2021</a>, p. 368)
      <i>California Herps</i>: <a>"Identifying California Snakes"</a>
    linked footnote citation:
      Russo, Ronald A. <i>Plant Galls of the Western United States</i>. Princeton University Press, 2021.

review txt files for plants with x:more
  or are missing x

since taxons that are directly observed can already pick up a common name
  from iNaturalist (or complain that the common name isn't already known),
  there's less need to warn about a directly observed taxon with no common name.
add another property like 'no_sci_not_obs'
  to flag an unobserved taxon with no common name.

flag places where the genus rank is inferred
  i.e. remains inferred after all sources are checked for elaborations

Give the user a way to edit/repeat the previous search
  When navigating away from a page, record the search field before clearing it
  After returning to the page, if the search field is empty, provide a
    'restore/refresh' button at the right end of the search field.
    Clicking the button restores the previous search value.
    The button disappears when anything is typed (or after a restore),
      but re-appears if the search field is cleared.
   Since a button cannot actually be within the search field,
     the search field should be contained within a larger div that has the
     appropriate border elements.
       :focus-within can be used to highlight the container when appropriate
  Perhaps it is easier to position the button on top of the search field
      without putting it within the focus element.
    text will never overlap the button because the button only appears when
      the text field is blank

Record native/alien status
  display as a small icon, e.g. to the right of the name

I've assigned a common name in the BAWG to a fair number of plant subspecies
    that don't have one in iNaturalist.
  Should I undo that?
    I think I shouldn't.
    I can use the scientific name in iNaturalist.  It's ugly, but whatever.
    Meanwhile, I can use my preferred common name in Lightroom and the BAWG.
  I could even make up more common names for my own purpose
    although perhaps they should be marked so as to avoid confusing others

finish more documentation

separate 'other dandelion-like flowers' from 'yellow dandelion-like flowers'

Support {--<name>} to link using a short name (common preferred), *or*
improve {-<name>} to link using a short name whenever the named taxon
is on the current page.  (I.e. it is the current page or is a direct
child.)  (Which means there should be a difference between a genus key
and the auto-generated species page.)

Support abbreviations for inline links: "{-name}"
    and membership: "member: E. coli"
  For inline links, it would be best to evaluate in the context of the child
    if possible.

Improve {-name} to write an abbreviated scientific name
  when it can be parsed in the current context.
  Use the child's context if used within a child declaration.

Besides converting spaces to hyphens in HTML file names,
  also remove any other characters that would end up percent encoded
  (or that are not allowed in Windows).
  consider also removing apostrophes and other special characters
    but perhaps not commas

does a high-level x attribute propagate down to lower levels?
  and complain about mismatches?
  does default_completeness flag before or after x propagation?
    what do I want it to do?

Change free-form x/xx text to still require a keyword, e.g.
  x:more:<free text>

galls should be under life
  and re-check its properties for duplicates or problems

mammals isn't a key
  but it is listed as one

allow an iNaturalist observation to create a real page
  e.g. 'obs_create'
  promotion stops where it reaches 'obs_create'
  implementation:
    in the first pass through observations.csv,
      mark pages that are directly observed
    when evaluating create/create2/link, also evaluate obs_create
      if a page isn't created,
	 push its observation flag to its Linnaean parent

'create2': 'fd' - for a shadow page with at least *two* potential links,
    promote it to real, create the links.
  If only one link is possible, nothing is done.
    I.e. don't create a rather boring extra level of hierarchy.
  Use create2 instead of create (e.g. for flower families)?
    and use member_name to name the family when it isn't created

'obs_create_com'
  similar to 'obs_create'
  create (or check) a page for an observation only if it has a common name
  promotion continues until it is stopped by this or a real page
  but where does the common name come from
    if the taxon isn't directly observed?

E.g. in fungi [...].txt:
  obs_create genus-below
  create2 family, genus, species
  create2_com self-/genus

Heck, create2_com might be handy in *every* kingdom
  perhaps as 'warn create2_com'
  'do create2_com' could leave behind redundant links

to stay below 10,000 requests per day (per 24 hours?)
  limit fetches in a single day to 5000
similarly stay below 5 GB per hour and 24 GB per day


taxa.csv useful fields:
id
scientificName
taxonRank
parentNameUsageID (extract ID from URL)

VernacularNames-english.csv useful fields:
id
vernacularName
locality
- might need to search for multiple locations to find California name
- e.g. "California, US", "United States", "North America"
- multiple localities are separated with " | "
- unclear how to find the "preferred name"

move API calls prior to parsing observation?
  the API has higher-quality data
  but we'd need to do more name lookups in the API
  but if we read the Taxa ZIP, then do the API, then read observations,
    it wouldn't be so bad


keep a record of genuses mentioned in a page
  e.g. sci, asci, sci_i, ==child
  and allow abbreviations to reference any
  abbreviation may be any number of characters followed by a period
  match must be unique


Why don't I promote unranked pages to be 'true' Linnaean parents?
  it would potentially avoid a bunch of hassle code
  if would the unranked page to interrupt property propagation
  only works if the page has a single parent
    so maybe it doesn't avoid much code
    could still be handy for property propagation and interruption, though
  do I already do this?
    the Linnaean parent is based on the lowest common ancestor among children

Does it make sense to augment member_name with  member_name_com?
  can use it much more liberally, then
and member_name_com_no_and
  excludes common names that include ' and ',
    e.g. useless groups such as "frogs and toads"
  same for other _com properties
Same with member_alias?
  or is this useful?

change obs_fill_* to inat_fill_*

obs_create doesn't work from lowest to highest,
  so it may create a page which it wouldn't if it knew it were going
    to create a real descendent
  but it's still useful as a temporary aid when updating info

I could create a function to help with rp_do for the various property variants
  foo
  foo_com
  foo_com_no_and

change ignore_species.yaml to ignore_properties.yaml
  taxon name: list of properties to ignore
  requires extra code for obs_promotion properties attached to an ancestor
    since the ignore is on the original (or intermediate)
  there's no single point in the BAWG parsing where all pages are present
      and the ignore instructions can be attached for future use
    the ignore file might need to be strictly 'sci' name based
      to allow easy lookups at any point in the parsing
    or have the ignore file create shadow pages (by com, sci, eval, or TID)
        and have those carry the ignore instructions
      this could be awkward if an iNat record matches multiple pages
        e.g. by either sci or TID

read taxa.csv (or condensed equivalent)
  for each page, apply TID, rank, chain
read observations.csv
  for each lowest level, find name with matching TID from taxa.csv (and mark)
    and use its rank
  if not found, guess rank as usual
  for each observation, apply TID, rank, chain
read iNat API data
  for each page, apply TID, rank, chain
... apply properties ...
apply names from taxa.csv, observations.csv, and API data
  in the reverse order of their file modification date (youngest first)
    if -api is used, API data is assumed to be youngest
    otherwise, use the youngest date in an API file
  taxa.csv may be older than its file date;
    perhaps always treat it as oldest

add an api-cache.pickle
  this is saved once all API transactions are complete
    but only when -api is used
    it includes only those taxa that are touched
    and then all JSON files are deleted
  the JSON files are retained if the script fails
  the script reads both the api-cache.pickle and the JSON files
    with preference to the JSON files, which are guaranteed newer
      wait, no they're not
    these files are read regardless of -api
  or condense the data before saving it as JSON or pickle

local Ceanothus oliganthus is always var. sorediatus (jim brush)

perhaps I shouldn't record 'elab' but instead stick with 'sci' and 'rank'.
  generate elab only as needed
  use rank as disambiguator

to resolve conflicts
  allow iNat sources to be ignored from the 'ignore_species.yaml' file
    (or whatever the file ends up being called)
  e.g. 'Octopictus: core' would ignore DarwinCore data for Octopictus
  'inat' (or 'iNat') can also be used to ignore all 3 iNat sources:
    observations, core, and API

Should autocomplete ask for 2 results to see if there are multiple matches
  for the same name and rank?
Should I get the kingdom IDs first to use as disambiguators?

Allow multiple forms of the same organism
  e.g. butterflies and caterpillars, insects and multiple gall types
  complicates every page lookup
  complicates Linnaean relationships if form is not the bottommost rank
    is this what the "form" rank is for?

use this form of search if a gallformers_id is provided
  and the name isn't at rank species or lower
https://www.inaturalist.org/observations/chris_nelson?order_by=observed_on&field:Gallformers%20Code=a-spp-whole-shoot-discoloration

distinguish between observations: "none" and "none in the bay area"
  and perhaps "not yet in the data" if there's a photo but no observations
  or "none as of {observations.csv date}"
  or "only recently"

combine 'key to' with 'member of', preserving hierarchical order
  usually no need to distinguish keys; either the next parent is useful or not
  but what to do with multiple keys, e.g. for non-taxonomic keys?
  perhaps put "(key)" after the name
    except the scientific name is already in parentheses

record the source(s) of each Linnaean link
allow priorities to be set
  txt is always highest
  any order of observations.csv, DarwinCore, API
    typical order might be to give the API highest priority
  in the event of a conflict, if necessary,
    reload the API data if the link came from the cached pickle,
      and it is older than a conflicting file (txt, observations.csv.zip, core)
        date/time comparison prevents repeated reloads
    undo a lower-priority link and replace it with a higher-priority link
as a partial workaround before that is done,
  provide a way to ignore cached API entries in any part(s) of the tree

The BAWG HTML doesn't update its notice area immediately
  when the service worker notices that it is out of date, but it should

Prioritize a taxon with a photo over another without a photo
  when they have equal observations (e.g. zero)

Advanced search:
  a search for a tag (e.g. 'purple flowers') or month or park goes to the
    'advanced search' page
  as does a search with no results
  if a simple search is performed on a tag, the tag is added to the
    original page's taxon (if any) in the advanced search results
  pages.js (or a variant) lists all taxons in hierarchy format
    ?including non-pages such as "basidiomycete fungi (phy7lum Basidiomycota)"?
  javascript generates the page content based on the search results
  if a taxon is found, a radio button allows additional taxons to be added
    vs. the default of replacing the taxon
  searching for a tag or month or park always adds it to the existing search
    each search term has a radio button to allow it to be removed
    if there are two or more in a category, a button allows all to be cleared
  when a search term is added, it is listed in the autocomplete results
    preceded with a '+'
  some terms are never added to an advanced search, e.g. glossary terms
  a search category is displayed by default only if it is included in a search
    but a link allows all search categories to be displayed
  unused tags in a category are not shown by default
    but a link allows all tags in a category to be displayed (e.g. all months)
  if a taxon is searched, all taxons under in the hierarchy are also considered
    to match
  when there are multiple matches for search terms, the minimum encompassing
    set of ancestors is included in the results
  since tags are repeated verbatim for many taxons, they are encoded
    an easy encoding is e.g. an uppercase letter followed by a lowercase letter
    a search can thus do a simple string query to find matches in the
      encoded tag string
    allows for 26*26=676 tag values even without going to base-64
    the 12 months are super common and could be encoded with single digits and
      some punctuation

The BAWG doc's summary of files should have a page reference for every file.

"Toxicity" links should go to a BAWG description and disclaimer before
linking to the CalPoison website.

fix up dumping and keyboard interrupts

always propagate (non-0) toxicity up to genus level, just in case

There's no way to recognize when iNaturalist's common name is updated.
  Can I do something with the DarwinCore data?
  Or must I occasionally expire and re-fetch the API data?
  e.g. "desert poppies"

california golden chanterelle is listed both under family Hydnaceae
  and class Agaricomycetes

more gallery keys:
  home for first photo (or default zoom and position?)
  end for last photo (or maximum zoom?)

2023-4-9 Sweeney Ridge is missing most keywords in Lightroom

blazingstars needs key
spineflowers needs key
